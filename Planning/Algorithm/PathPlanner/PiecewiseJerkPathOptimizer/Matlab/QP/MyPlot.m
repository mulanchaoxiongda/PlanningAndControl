function [] = MyPlot(road_width, path_data, sample_interval, reference_speed, ...
        l_bound, dl_bound, ddl_bound, dddl_bound, obstacle_avoid_bound, ...
        ego_para, distance_lon, reference_line, control_constraint, ...
        obstacle_bound, integral_step, lane_width, obs_info)
    gate_animation = true;
    
    % visulization in map coordinate system
    path_data = ...
            VisulizationMap(road_width, path_data, sample_interval, ...
            reference_speed, l_bound, dl_bound, ddl_bound, dddl_bound, ...
            obstacle_avoid_bound, ego_para, distance_lon, reference_line, ...
            control_constraint, obstacle_bound, integral_step, lane_width, ...
            gate_animation, obs_info);
        
    % visulization in frenet coordinate system
    VisulizationFrenet( ...
            road_width, path_data, sample_interval, reference_speed, l_bound, ...
            dl_bound, ddl_bound, dddl_bound, obstacle_avoid_bound, ...
            ego_para, distance_lon, reference_line, control_constraint, ...
            obstacle_bound, gate_animation, obs_info);
        
    % analysis constraints
    AnalysisConstraints( ...
        road_width, path_data, sample_interval, reference_speed, l_bound, ...
        dl_bound, ddl_bound, dddl_bound, obstacle_avoid_bound, ego_para, ...
        distance_lon, reference_line, control_constraint, obstacle_bound);
end

% analysis constraints
function [] = ...
        AnalysisConstraints(road_width, path_data, sample_interval, ...
        reference_speed, l_bound, dl_bound, ddl_bound, dddl_bound, ...
        obstacle_avoid_bound, ego_para, distance_lon, reference_line, ...
        control_constraint, obstacle_bound)
    figure('name', 'constraints');
    subplot(4, 2, 1);
    plot([0 : sample_interval : distance_lon], l_bound.lb(:), '-r', ...
         [0 : sample_interval : distance_lon], l_bound.ub(:), '-r', ...
         [0, distance_lon], [ road_width / 6,  road_width / 6], 'r', ...
         [0, distance_lon], [-road_width / 6, -road_width / 6], 'r', ...
         [0 : sample_interval : distance_lon], obstacle_avoid_bound.lb_head(:), 'oy', ...
         [0 : sample_interval : distance_lon], obstacle_avoid_bound.lb_back(:), 'oy', ...
         [0 : sample_interval : distance_lon], obstacle_avoid_bound.ub_head(:), 'oy', ...
         [0 : sample_interval : distance_lon], obstacle_avoid_bound.ub_back(:), 'oy', ...
         [0 : sample_interval : distance_lon], obstacle_bound.lb_head(:), 'oblack', ...
         [0 : sample_interval : distance_lon], obstacle_bound.lb_back(:), 'oblack', ...
         [0 : sample_interval : distance_lon], obstacle_bound.ub_head(:), 'oblack', ...
         [0 : sample_interval : distance_lon], obstacle_bound.ub_back(:), 'oblack', ...
         path_data.s(:), path_data.l(:), 'b', ...
         [0 : sample_interval : distance_lon], zeros(1, round(distance_lon / sample_interval + 1)),'-.g');
     title('s-l'); xlabel('s(m)'); ylabel('l(m)');
     
     subplot(4, 2, 2);
     plot([0 : sample_interval : distance_lon], dl_bound.lb(:), 'r', ...
          [0 : sample_interval : distance_lon], dl_bound.lb(:), 'r', ...
         path_data.s(:), path_data.dl(:), 'b');
     title('dl'); xlabel('s(m)'); ylabel('dl()');
     
     subplot(4, 2, 3);
     plot([0 : sample_interval : distance_lon], ddl_bound.lb(:), 'r', ...
          [0 : sample_interval : distance_lon], ddl_bound.ub(:), 'r', ...
         path_data.s(:), path_data.ddl(:), 'b');  title('ddl');
      title('ddl'); xlabel('s(m)'); ylabel('ddl()');
      
     subplot(4, 2, 4);
     plot([0 : sample_interval : distance_lon - sample_interval], dddl_bound.lb(:), 'r', ...
          [0 : sample_interval : distance_lon - sample_interval], dddl_bound.ub(:), 'r', ...
         path_data.s(:), path_data.dddl(:), 'b'); 
      title('dddl'); xlabel('s(m)'); ylabel('dddl()');
      
     [kappa_frenet, kappa_rate_frenet, kappa_bound_frenet, kappa_rate_bound_frenet] = ...
             CalKappaAndKappaRate(path_data, ddl_bound, ...
             control_constraint, reference_line);
         
     subplot(4, 2, 5);
     plot([0 : sample_interval : distance_lon], kappa_bound_frenet.lb(:), 'r', ...
          [0 : sample_interval : distance_lon], kappa_bound_frenet.ub(:), 'r', ...
         path_data.s(:), kappa_frenet(:), 'b');
     title('kappa(frenet)'); xlabel('s(m)'); ylabel('kappa()');
     
     subplot(4, 2, 6);
     plot([0 : sample_interval : distance_lon], kappa_rate_bound_frenet.lb(:), 'r', ...
          [0 : sample_interval : distance_lon], kappa_rate_bound_frenet.ub(:), 'r', ...
          path_data.s(:), kappa_rate_frenet(:), 'b');
     title('kappa rate(frenet)'); xlabel('s(m)'); ylabel('kappa change rate()');
     
     subplot(4, 2, 7);
     plot([0, distance_lon], [ control_constraint.kappa_max,  control_constraint.kappa_max], 'r', ...
          [0, distance_lon], [-control_constraint.kappa_max, -control_constraint.kappa_max], 'r', ...
          path_data.s(:), path_data.kappa_map_scatter(:), 'green', ...
          path_data.s(:), path_data.kappa_map(:), 'b');
     title('kappa(map)'); xlabel('s(m)'); ylabel('kappa()');
     
     subplot(4, 2, 8);
     plot(path_data.s(:), path_data.kappa_rate_map(:), 'b', ...
          [0, distance_lon], [ control_constraint.kappa_rate_max,  control_constraint.kappa_rate_max], 'r', ...
          [0, distance_lon], [-control_constraint.kappa_rate_max, -control_constraint.kappa_rate_max], 'r');
     title('kappa rate(map)'); xlabel('s(m)'); ylabel('kappa change rate()');    
end

%calculate kappa && dkappa / dt in frenet
function [kappa_frenet, kappa_rate_frenet, kappa_bound_frenet, kappa_rate_bound_frenet] = CalKappaAndKappaRate( ...
        path_data, ddl_bound, control_constraint, reference_line)
    kappa_frenet = path_data.ddl ./ (1 + path_data.dl.^2).^1.5;
    kappa_rate_frenet = ...
            (path_data.dddl .* ((1 + path_data.dl.^2).^1.5) - ...
            path_data.ddl .* (1.5 .* (1 + path_data.dl.^2).^0.5 .* ...
            2 .* path_data.dl .* path_data.ddl)) ./ (1 + (path_data.dl).^2).^3;
        
    kappa_bound_frenet.lb = ddl_bound.lb;
    kappa_bound_frenet.ub = ddl_bound.ub;
    kappa_rate_bound_frenet.lb = ...
            -control_constraint.kappa_rate_max - reference_line.dkappa_dt;
    kappa_rate_bound_frenet.ub = ...
             control_constraint.kappa_rate_max - reference_line.dkappa_dt;
end

function [] =VisulizationFrenet( ...
         road_width, path_data, sample_interval, reference_speed, ... 
         l_bound, dl_bound, ddl_bound, dddl_bound, obstacle_avoid_bound, ...
         ego_para,distance_lon, reference_line, ...
         control_constraint, obstacle_bound, gate_animation, obs_info)
    figure('name', 'driving animation(frenet)');
    plot([0 : sample_interval : distance_lon], l_bound.lb(:), '-r', ...
         [0 : sample_interval : distance_lon], l_bound.ub(:), '-r', ...
         [0, distance_lon], [ road_width / 6,  road_width / 6], 'r', ...
         [0, distance_lon], [-road_width / 6, -road_width / 6], 'r', ...
         [0 : sample_interval : distance_lon], obstacle_bound.lb_head(:), 'oblack', ...
         [0 : sample_interval : distance_lon], obstacle_bound.lb_back(:), 'oblack', ...
         [0 : sample_interval : distance_lon], obstacle_bound.ub_head(:), 'oblack', ...
         [0 : sample_interval : distance_lon], obstacle_bound.ub_back(:), 'oblack', ...
         path_data.s(:), path_data.l(:), 'b', ...
         [0 : sample_interval : distance_lon], zeros(1, round(distance_lon / sample_interval + 1)), '-.g');
     title('s-l'); xlabel('s(m)'); ylabel('l(m)'); hold on; axis equal;
     set(gca, 'Xlim', [-ego_para.rear2back, ...
         path_data.s(length(path_data.s)) + ego_para.rear2front]);
     
     obs_info.corner_s = ...
             [obs_info.s - obs_info.length / 2, obs_info.s - obs_info.length / 2, ...
              obs_info.s + obs_info.length / 2, obs_info.s + obs_info.length / 2, ...
              obs_info.s - obs_info.length / 2];
     obs_info.corner_l = ...
             [obs_info.l - obs_info.width / 2, obs_info.l + obs_info.width / 2, ...
              obs_info.l + obs_info.width / 2, obs_info.l - obs_info.width / 2, ...
              obs_info.l - obs_info.width / 2];
     plot(obs_info.corner_s(:), obs_info.corner_l(:), '*-m'); hold on;
     
     plot([0 : sample_interval : distance_lon], obstacle_avoid_bound.lb_back(:), '--c'); hold on;
     plot([0 : sample_interval : distance_lon], obstacle_avoid_bound.ub_back(:), '--c'); hold on;
     
     s = path_data.s(1);
     l = path_data.l(1);
     theta = atan(path_data.dl(1));
     
     [sVehBound, lVehBound] = calVehicleConner(s, l, theta, ego_para);
     
     if gate_animation
         h1 = plot(sVehBound, lVehBound, 'black'); % vehicle outline
         h2 = plot(s, l, 'r*', 'MarkerSize', 10); % rear axle center
     else
         h1 = plot(sVehBound, lVehBound, 'black');
         hold on;
         h2 = plot(s, l, 'r*', 'MarkerSize', 10); 
         hold on;
     end
     
     for idx = 2 : 1 : length(path_data.s)
         s = path_data.s(idx);
         l = path_data.l(idx);
         theta = atan(path_data.dl(idx));
         
         [sVehBound, lVehBound] = calVehicleConner(s, l, theta, ego_para);
         
         if gate_animation
             h1.XData = sVehBound;
             h1.YData = lVehBound;
             
             h2.XData = s;
             h2.YData = l;
             
             pause(0.05);
         else
             plot(sVehBound, lVehBound, 'black');
             hold on;
         end
     end
end

% calculate the pose of the vehicle frame according to the pose of the center of the rear axle
function [xVehBound, yVehBound] = calVehicleConner(x, y, yaw, ego_para)
    cornerFL = [ ego_para.rear2front,   ego_para.width / 2]';
    cornerFR = [ ego_para.rear2front,  -ego_para.width / 2]';
    cornerRL = [-ego_para.rear2back,   ego_para.width / 2]';
    cornerRR = [-ego_para.rear2back,  -ego_para.width / 2]';
    
    posRearCenter = [x, y]'; % vehicle position--map
    
    transMatrix = [cos(yaw) sin(yaw);  %body2map
                  -sin(yaw) cos(yaw)]';
              
    cornerFL = transMatrix * cornerFL + posRearCenter;
    cornerFR = transMatrix * cornerFR + posRearCenter;
    cornerRL = transMatrix * cornerRL + posRearCenter;
    cornerRR = transMatrix * cornerRR + posRearCenter;
         
    xVehBound = ...
            [cornerFL(1), cornerFR(1), cornerRR(1), cornerRL(1), cornerFL(1)];
    yVehBound = ...
            [cornerFL(2), cornerFR(2), cornerRR(2), cornerRL(2), cornerFL(2)];
end

function [path_data] = VisulizationMap( ...
        road_width, path_data, sample_interval, reference_speed, l_bound, ... 
        dl_bound, ddl_bound, dddl_bound, obstacle_avoid_bound, ego_para, ...
        distance_lon, reference_line, control_constraint, obstacle_bound, ...
        integral_step, lane_width, gate_animation, obs_info)
    idx = 1;
    s = 0;
    step = path_data.step;
    
    counter = 0;
    
    while s <= reference_line.sample_interval * (reference_line.num_of_knots - 1) + 0.0001
        center_corner = s / reference_line.turning_radius; % turn left
        
        turning_radius = reference_line.turning_radius;
        ref_line.x(idx, 1) = cos(center_corner) * turning_radius;
        ref_line.y(idx, 1) = sin(center_corner) * turning_radius;
        ref_line.theta(idx, 1) = center_corner;
        ref_line.kappa(idx, 1) = 1 / reference_line.turning_radius;
        
        turning_radius = reference_line.turning_radius + lane_width / 2;
        lane_boundary.x(idx, 1) = cos(center_corner) * turning_radius;
        lane_boundary.y(idx, 1) = sin(center_corner) * turning_radius;
        
        turning_radius = reference_line.turning_radius - lane_width / 2;
        lane_boundary.x(idx, 2) = cos(center_corner) * turning_radius;
        lane_boundary.y(idx, 2) = sin(center_corner) * turning_radius;
        
        turning_radius = reference_line.turning_radius + road_width / 2;
        lane_boundary.x(idx, 3) = cos(center_corner) * turning_radius;
        lane_boundary.y(idx, 3) = sin(center_corner) * turning_radius;
        
        turning_radius = reference_line.turning_radius - road_width / 2;
        lane_boundary.x(idx, 4) = cos(center_corner) * turning_radius;
        lane_boundary.y(idx, 4) = sin(center_corner) * turning_radius;
        
        theta_match_point = center_corner + pi / 2;
        
        trans_matrix_frenet2map = ...
                [cos(-theta_match_point), sin(-theta_match_point)
                 -sin(-theta_match_point), cos(theta_match_point)];
             
        poisition_map    = ...
                 trans_matrix_frenet2map * [0; path_data.l(idx)] + ...
                 [ref_line.x(idx, 1); ref_line.y(idx, 1)];
        path_data.x(idx) = poisition_map(1);
        path_data.y(idx) = poisition_map(2);
        
        velocity_map          = ...
                trans_matrix_frenet2map * ([reference_speed; ...
                path_data.dl(idx) * reference_speed] + reference_speed / ...
                reference_line.turning_radius * [-path_data.l(idx); 0]); % simplify processing
        path_data.vx(idx)    = velocity_map(1);
        path_data.vy(idx)    = velocity_map(2);
        
        acceleration_map   = ...
                trans_matrix_frenet2map * ([0; path_data.ddl(idx) * ...
                reference_speed^2] + reference_speed / ...
                reference_line.turning_radius * [-path_data.dl(idx); ...
                reference_speed]); % simplify processing
        path_data.ax(idx) = acceleration_map(1);
        path_data.ay(idx) = acceleration_map(2);
        
        rotation_angle_frenet2map = -theta_match_point;
        phi_ref = rotation_angle_frenet2map;
        phi = phi_ref;
        
        s_ref = 0; l = path_data.l(idx);
        path_data.x2(idx) = ...
                cos(phi) * s_ref + sin(phi) * l + ref_line.x(idx,1);
        path_data.y2(idx) = ...
               -sin(phi) * s_ref + cos(phi) * l + ref_line.y(idx,1);  
           
        ds_dt = reference_speed; dl_dt = path_data.dl(idx) * ds_dt;
        dphi_dt = -ds_dt / reference_line.turning_radius; ... % turn left
        path_data.vx2(idx) = -sin(phi) * dphi_dt * s_ref + ...
                             cos(phi) * ds_dt + ...
                             cos(phi) * dphi_dt * l + ...
                             sin(phi) * dl_dt;
        path_data.vy2(idx) = -cos(phi) * dphi_dt * s_ref - ...
                             sin(phi) * ds_dt - ...
                             sin(phi) * dphi_dt * l + ...
                             cos(phi) * dl_dt;  
                         
        dds_ddt = 0; dradius_dt = 0;
        ddl_ddt = path_data.ddl(idx) * ds_dt *  ds_dt + ...
                  path_data.dl(idx) * dds_ddt;
        ddphi_ddt = -(dds_ddt * reference_line.turning_radius - ...
                     ds_dt * dradius_dt) / reference_line.turning_radius^2;
        path_data.ax2(idx) =  ...
                -cos(phi) * dphi_dt * dphi_dt * s_ref  ...
                -sin(phi) * (ddphi_ddt * s_ref + dphi_dt * ds_dt) ...
                -sin(phi) * dphi_dt * ds_dt ...
                +cos(phi) * dds_ddt ...
                -sin(phi) * dphi_dt * dphi_dt * l ...
                +cos(phi) * (ddphi_ddt * l + dphi_dt * dl_dt) ...
                +cos(phi) * dphi_dt * dl_dt ...
                +sin(phi) * ddl_ddt;
        path_data.ay2(idx) =  ...
                sin(phi) * dphi_dt * dphi_dt * s_ref  ...
                -cos(phi) * (ddphi_ddt * s_ref + dphi_dt * ds_dt) ...
                -cos(phi) * dphi_dt * ds_dt ...
                -sin(phi) * dds_ddt ...
                -cos(phi) * dphi_dt * dphi_dt * l ...
                -sin(phi) * (ddphi_ddt * l + dphi_dt * dl_dt) ...
                -sin(phi) * dphi_dt * dl_dt ...
                +cos(phi) * ddl_ddt;   
        
            path_data.theta3(idx) =  atan2(path_data.vy(idx), path_data.vx(idx));
            path_data.theta2(idx) =  atan2(path_data.vy2(idx), path_data.vx2(idx));
            path_data.theta(idx) = ...
                    atan(path_data.dl(idx) / (1 - path_data.l(idx) / ...
                    reference_line.turning_radius)) + theta_match_point;
                
            path_data.kappa_map3(idx) = ...
                    (path_data.vx(idx) * path_data.ay(idx) - ...
                    path_data.ax(idx) * path_data.vy(idx)) / ...
                    (path_data.vx(idx)^2 + path_data.vy(idx)^2)^1.5;
               
            path_data.kappa_map2(idx) = ...
                    (path_data.vx2(idx) * path_data.ay2(idx) - ...
                    path_data.ax2(idx) * path_data.vy2(idx)) / ...
                    (path_data.vx2(idx)^2 + path_data.vy2(idx)^2)^1.5 - ...
                    1 / reference_line.turning_radius;
                
            delta_theta = path_data.theta3(idx) - theta_match_point;
            path_data.kappa_map(idx) = ...
                    (((path_data.ddl(idx) + ...
                     (path_data.dl(idx)/ reference_line.turning_radius) * ...
                     tan(delta_theta)) * cos(delta_theta)^2) / ...
                     (1 - path_data.l(idx) / reference_line.turning_radius) + ...
                     1 / reference_line.turning_radius) * ...
                    (cos(delta_theta) / (1 - path_data.l(idx) / ...
                    reference_line.turning_radius));
                
            s = s + step;
            idx = idx + 1;
    end
    
    idx = idx - 1;
    for index = 2 : 1 : idx - 1
        vector_first = [path_data.x(index) - path_data.x(index - 1); ...
                        path_data.y(index) - path_data.y(index - 1)];
        vector_second = [path_data.x(index + 1) - path_data.x(index);...
                         path_data.y(index + 1) - path_data.y(index)];
                     
        angel_change = ...
                atan2(vector_second(2), vector_second(1)) - ...
                atan2(vector_first(2), vector_first(1));
        arc_length   = (norm(vector_first) + norm(vector_second)) / 2;
        
        path_data.kappa_map_scatter(index) = angel_change / arc_length;
    end
    
    path_data.kappa_map_scatter(1) = path_data.kappa_map_scatter(2);
    path_data.kappa_map_scatter(idx) = path_data.kappa_map_scatter(idx - 1);
    
    for index = 3 : 1 : idx - 1
        delta_s = ...
                norm([path_data.x(index) - path_data.x(index - 1), ...
                        path_data.y(index) - path_data.y(index - 1)]);
        path_data.kappa_rate_map(index) = ...
                (path_data.kappa_map(index) - ...
                path_data.kappa_map(index - 1)) / delta_s;
    end
    path_data.kappa_rate_map(2) = path_data.kappa_rate_map(3);
    path_data.kappa_rate_map(1) = path_data.kappa_rate_map(2);
    path_data.kappa_rate_map(idx) = path_data.kappa_rate_map(idx - 1);
    
    for idx = 1 : 1 : reference_line.num_of_knots
        x_match_point = reference_line.x(idx, 1);
        y_match_point = reference_line.y(idx, 1);
        theta_match_point = reference_line.theta(idx, 1);
        trans_matrix = [ cos(-theta_match_point), sin(-theta_match_point)
                        -sin(-theta_match_point), cos(-theta_match_point)];
                    
        l = obstacle_bound.lb_back(idx);
        position_map = trans_matrix * [0;l] + [ x_match_point; y_match_point];
        obstacle_bound.lb_back_x(idx) = position_map(1);
        obstacle_bound.lb_back_y(idx) = position_map(2);
        
        l = obstacle_bound.ub_back(idx);
        position_map = trans_matrix * [0; l] + [x_match_point; y_match_point];
        obstacle_bound.ub_back_x(idx) = position_map(1);
        obstacle_bound.ub_back_y(idx) = position_map(2);

        l = obstacle_bound.lb_head(idx);
        position_map = trans_matrix * [0;l] + [ x_match_point; y_match_point];
        obstacle_bound.lb_head_x(idx) = position_map(1);
        obstacle_bound.lb_head_y(idx) = position_map(2);
             
        l = obstacle_bound.ub_head(idx);
        position_map = trans_matrix * [0;l] + [ x_match_point; y_match_point];
        obstacle_bound.ub_head_x(idx) = position_map(1);
        obstacle_bound.ub_head_y(idx) = position_map(2);
    end
    
    figure('name', 'driving animation(map)');
    plot(ref_line.x(:, 1), ref_line.y(:, 1), '-.g', ...
         lane_boundary.x(:, 1),lane_boundary.y(:, 1), 'r', ...
         lane_boundary.x(:, 2),lane_boundary.y(:, 2), 'r', ...
         lane_boundary.x(:, 3),lane_boundary.y(:, 3), '-r', ...
         lane_boundary.x(:, 4),lane_boundary.y(:, 4), '-r', ...
         obstacle_bound.lb_back_x(:), obstacle_bound.lb_back_y(:), 'oblack', ...
         obstacle_bound.ub_back_x(:), obstacle_bound.ub_back_y(:), 'oblack', ...
         obstacle_bound.lb_head_x(:), obstacle_bound.lb_head_y(:), 'oblack', ...
         obstacle_bound.ub_head_x(:), obstacle_bound.ub_head_y(:), 'oblack', ...
         path_data.x(:), path_data.y(:), 'b');
    title('x-y'); xlabel('x(m)'); ylabel('y(m)'); axis equal; hold on;
    
    [xVehBound, yVehBound] = ...
            calVehicleConner( path_data.x(1), path_data.y(1), path_data.theta(1), ego_para);
        
    if gate_animation
        h1 = plot(xVehBound, yVehBound, 'black'); % vehicle outline
        h2 = plot(path_data.x(1), path_data.y(1), 'r*', 'MarkerSize', 10); % rear axle center;
    else
        h1 = plot(xVehBound, yVehBound, 'black'); % vehicle outline
        hold on;
        h2 = plot(path_data.x(1), path_data.y(1), 'r*', 'MarkerSize', 10);
        hold on;
    end
    
    for idx = 2 : 1 : length(path_data.s)
        [xVehBound, yVehBound] = calVehicleConner( ...
                path_data.x(idx), path_data.y(idx), path_data.theta(idx), ego_para);
            
        if gate_animation
            h1.XData = xVehBound;
            h1.YData = yVehBound;
            
            h2.XData = path_data.x(idx);
            h2.YData = path_data.y(idx);
            
            pause(0.05);
        else
            plot(xVehBound, yVehBound, 'black'); % vehicle outline
            hold on;
        end
    end
end
